## Clean Code

### Clean Code란 무엇인가?
- 우아하고 효율적인 코드
- 논리가 간단 --> 버그 방지
- 의존성을 최대한 줄인다 --> 유지보수 용이
- 오류는 명백한 전략에 의거해 철저히 처리
- 성능 최적 유지
---
- 깨끗한 코드는 누구나 읽기 쉽고 고치기 쉽다
- 단위 테스트 케이스와 인수 테스트 케이스가 존재한다
- 의미있는 이름이 붙는다
- 특정 목적을 달성하는 방법은 하나만 제공한다
- 의존성은 최소이며, 각 의존성을 명확히 정의한다
- API는 명확하며 최소로 줄였다
- 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다
---
- 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다
- 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
---
- 중복이 없다, 시스템 내 모든 설계 아이디어를 표현한다.
- 클래스, 메서드, 함수 등을 최대한 줄인다.
---
- 읽기 쉬운 코드
- 전달하고자 하는 바를 명확하게 알려주는 코드
- 개발자의 의도가 모두 담겨있는 코드
---
### Clean Code가 필요한 이유
- 신규 구축 프로젝트가 아닌 경우가 대부분이며, 타인이 내 코드를 볼 때 이해하기 쉽게 해야한다.
---
### 의미있는 이름
- 의도를 분명히 밝혀라 
  - 변수명 명확하게 (ex. list, x 등 사용하지 않는다)
- 그릇된 정보를 피하라
  - getUserList 라는 메서드의 return은 User.. 
- 의미있게 구분하라 
  - User / UserInfo / UserData / UserDetail / UserDetailInfo / UserDetailData , 서로 비슷한 개념의 이름 최대한 지양
- 발음하기 쉬운 이름을 사용하라 
- 검색하기 쉬운 이름을 사용하라
  - list, day : 너무 일반적인 단어로 검색결과가 너무 많음
  - product, prdt, prd, p : 사람마다 줄이는 기준이 다르다. 여러번 검색해야하며, 놓치는 부분이 생길 수 있음
- 인코딩을 피하라
- 자신의 기억력을 자랑하지 마라
- 클래스 이름
  - User, Payment 와 같이 명사나 명사구 사용
  - Fly, Buy (x)
- 메서드 이름
  - getName(), pay() 와 같이 동사나 동사구 사용
  - money(), food() (X)
- 기발한 이름은 피하라
- 한 개념에 한 단어를 사용하라
  - User / Member / Customer : 하나만 사용한다.
- 말장난을 하지마라
- 해법 영역에서 가져온 이름을 사용하라
- 문제 영역에서 가져온 이름을 사용하라
- 의미 있는 맥락을 추가하라
- 불필요한 맥락을 없애라
---
### 함수
- 작게 만들어라
  - 함수를 만드는 첫째 규칙은 '작게!', 둘 째 규칙은 '더 작게!' 이다.
- 한가지만 해라
  - 함수는 한가지를 해야 한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다.
- 함수 당 추상화 수준은 하나로 (위에서 아래로 코드 읽기: 내려가기 규칙)
  - ex) userInfo = "user@@1990@@12@@20" 이라는 정보를 파싱하여 생일이 오늘인지 비교하는 함수
  - 함수1 : userInfo로부터 split을 통해 생일을 얻는다.
  - 함수2 : 오늘 날짜와 비교하고 결과 리턴
- Switch문의 사용법
- 서술적인 이름을 사용하라
- 함수 인수
  - 이상적인 인수 갯수는 0개(무항)
  - 3개는 가능한 피하는 편이 좋다
  - 4개는 특별한 이유가 필요하다, 특별한 이유가 있어도 사용하면 안된다. 
  - 규칙에 따라서 몇가지 함수로 나누거나 DTO를 사용한다.
- 부수 효과를 일으키지 마라
- 명령과 조회를 분리하라
- 오류 코드보다 예외를 사용하라
- 반복하지 마라 (DRY - Don't Repeat Yourself)
- 구조적 프로그래밍
---
### 주석
- 주석은 나쁜 코드를 보완하지 못한다
- 코드의 의미를 표현하라
- 좋은 주석
  - 법적인 주석
  - 정보를 제공하는 주석
  - 의도를 설명하는 주석
  - 의미를 명료하게 밝히는 주석
  - 결과를 경고하는 주석
  - TODO 주석
  - 중요성을 강조하는 주석
  - 공개API에서 Javadocs
- 나쁜 주석
  - 주절거리는 주석
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 이력을 기록하는 주석
  - 있으나 마나 한 주석
  - 무서운 잡음
  - 함수나 변수로 표현할 수 있다면 주석을 달지 마라
  - 위치를 표시하는 주석
  - 닫는 괄호에 다는 주석
  - 공로를 돌리거나 저자를 표시하는 주석
  - 주석으로 처리한 코드
  - HTML 주석
  - 전역 정보
  - 너무 많은 정보
  - 모호한 관계
  - 함수 헤더
  - 비공개 코드에서 Javadocs
---
### 형식 맞추기
- 적절한 행 길이를 유지하라
  - 신문 기사처럼 작성하라 (위에서 아래로 읽을 수 있는 코드)
  - 개념은 빈 행으로 분리하라
  - 세로 밀집도
  - 수직 거리
    - 서로 밀접한 개념은 세로로 가까이 둬야 한다. (Find, Save, Modfiy, Delete 등)
    - 서로 밀접한 개념은 한 파일에 속해야 마땅하다.
- 가로 형식 맞추기
- 팀 규칙
---
### 객체와 자료구조
- 자료추상화
- 자료/객체 비대칭
  - 자료구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
  - 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
- 디미터 법칙
  - 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
    - 클래스 C
    - f가 생성한 객체
    - f인수로 넘어온 객체
    - C 인스턴스 변수에 저장된 객체
- 자료 전달 객체
---
### 오류 처리
- 오류코드보다 `예외`를 사용하라
- `Try-Catch-Finally`문 부터 작성하라
- `미확인(unchecked) 예외`를 사용하라
  - 
- 예외에 의미를 제공하라
- 호출자를 고려해 예외 클래스를 정의하라
- 정상 흐름을 정의하라
- `null`을 반환하지 마라
- `null`을 전달하지 마라
---
### 경계
- 외부 코드 사용하기
- 경계 살피고 익히기
- log4j 익히기
- 학습 테스트는 공짜 이상이다
  - 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
- 아직 존재하지 않는 코드를 사용하기
- 깨끗한 경계
---
### 단위 테스트
- TDD 법칙 세 가지
  - 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 깨끗한 테스트 코드 유지하기
- 깨끗한 테스트 코드
- 테스트 당 assert 하나
- FIRST 원칙
  - Fast
  - `Independant`
  - Repeatable
  - Self-Validating
  - Timly
---
### 클래스
- 클래스 체계
- 클래스는 작아야 한다
- 변경하기 쉬운 클래스
---
### 시스템
- 시스템 제작과 시스템 사용을 분리하라
- 확장
- 자바 프록시
- 순수 자바 AOP 프레임워크
- AspectJ 관점
- 테스트 주도 시스템 아키텍처 구축
- 의사 결정을 최적화하라
- 명백한 가치가 있을 때 표준을 현명하게 사용하라
- 시스템은 도메인 특화 언어가 필요하다
---
### 창발성
- 창발적 설계로 깔끔한 코드를 구현하자
  - 모든 테스트를 실행한다
  - 중복을 없앤다
  - 프로그래머 의도를 표현한다
  - 클래스와 메서드 수를 최소로 줄인다
- 단순한 설계 규칙
  - 모든 테스트를 실행하라
  - 리팩터링
- 중복을 없애라
- 표현하라
- 클래스와 메서드 수를 최소로 줄여라
---
### 동시성
- 동시성이 필요한 이유
- 동시성 방어 원칙
  - 단일 책임 원칙 (SRP)
  - 자료 범위를 제한하라
  - 자료 사본을 사용하라
  - 스레드는 가능한 독립적으로 구현하라
- 라이브러리를 이해하라
- 실행 모델을 이해하라
- 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화하는 부분을 작게 만들어라
- 올바른 종료 코드는 구현하기 어렵다
- 스레드 코드 테스트하기
  - 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
  - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
  - 프로세서 수보다 많은 스레드를 돌려보라
  - 다른 플랫폼에서 돌려보라
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
  - 직접 구현하기
  - 자동화
---
### 점진적인 개선
---
### JUnit 들여다보기
--- 
### SerialDate 리팩터링
---
### 냄새와 휴리스틱

